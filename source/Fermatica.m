(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["Fermatica`"]


$FermatCMD=Environment["FERMATPATH"];


$FermatTempDir=$TemporaryDirectory<>"/";


FermatDetachedSession;GetOutput;GetInput;
FermatSession;ParallelFermatSessions;
FDot;
FDotBig;
FPlus;
FInverse;
FTransform;
FDet;
FNormalize;
FKer;
FRowEchelon;
FQuolyMod;
FPolyLeadingTerm;FPolyLeadingOrder;
FGaussSolve;
FTogether;


$FermaticaHomeDirectory=DirectoryName[$InputFileName];


$FermaticaVersion="1.01";


System`PartitionWithRemainder::usage="PartitionWithRemainder[list,size] does the same as Partition[list,size], but does not omit the trailing elements if the chunk size does not divide list length.\nE.g. PartitionWithRemainder[{a,b,c,d,e,f,g,h},3] yields {{a,b,c},{d,e,f},{g,h}}.\n Works also for multidimensional arrays.";
System`PartitionWithRemainder=Fold[Replace[#,{}:>Sequence[],{#2}]&,Partition[#1,#2,#2,If[Length[#2]>1,{1,1}&/@#2,{1,1}],{}],Reverse[Length[#2]+Range[Length[#2]]]]&(*(Partition[#1,#2,#2,If[Length[#2]>1,{1,1}&/@#2,{1,1}],{}]//.{}\[RuleDelayed]Sequence[])&;*)


Begin["`Private`"]


todolist={};
todo[s_String]:=AppendTo[todolist,s];


todo["write *::usage for each command"];


todo["make FGaussSolve work correctly with inhomogeneous equations. Or at least, detect them."]


todo["adjust Fermatica to batch run. Run\[Rule]False option is not sufficient as it does not save the information about the Mathematica names of the variables."];


todo["Prevent printing huge Fermat output at error"];


SetAttributes[CStaticMonitor,{HoldFirst}];
CStaticMonitor[code_,msg_String,delay_:0]:=If[$Notebooks,
Monitor[code,msg,delay],
WriteString["stdout","["<>msg];(WriteString["stdout","]\n"];#)&[code]
];


SetAttributes[CMonitor,{HoldAll}];
CMonitor[code_,mon_,delay_:0,msg_String:""]:=If[$Notebooks,
Monitor[code,mon,delay],
If[msg=!="",WriteString["stdout","["<>msg]];(If[msg=!="",WriteString["stdout","]\n"]];#)&[code]
];


CPrint[ex__]:=If[$Notebooks,Print[ex],WriteString["stdout",#]&/@{ex,"\n"}];
CPrintTemporary[ex__]:=If[$Notebooks,PrintTemporary[ex],WriteString["stdout",#]&/@{"(",ex,")\n"}];


CWrite[msg_String]:=If[!$Notebooks,WriteString["stdout",msg]];


CProgress[i_,l_]:=(Which[l-i>10^4,If[Mod[i,10^3]==0,CWrite["M"]],l-i>10^3,If[Mod[i,10^2]==0,CWrite["C"]],l-i>10^2,If[Mod[i,10]==0,CWrite["X"]],True,CWrite["."]]);


SetAttributes[CProgressPrint,HoldFirst];
CProgressPrint[p_Symbol,i_,l_]:=Module[{step=Which[l-p>=10^3,10^3,l-p>=5 10^2,5 10^2,l-p>=10^2,10^2,l-p>=5 10,5 10,l-p>=10,10,l-p>=5,5,True,1],n},
If[Not[TrueQ[p>=0]],CWrite["["<>ToString[l]<>"|"];p=0;];
If[TrueQ[i>=p+step],
n=Quotient[ i-p,step];
p+=n*step;
CWrite["."<>ToString[p]](*CWrite[StringRepeat[RomanNumeral[step],n]]*);
];
If[i>=l,CWrite["]\n"]]
];


CPrint["\n******************** ",Style["Fermatica v"<>ToString[$FermaticaVersion],{Bold}]," ********************\n\
Inteface to ",Hyperlink["Fermat CAS", "http://home.bway.net/lewis/"],".\n\[Copyright] Roman N. Lee, 2018.\nRead from: "<>$InputFileName<>" (CRC32: "<>ToString[FileHash[$InputFileName,"CRC32"]]<>")","\n\n$FermatCMD=\""<>ToString[$FermatCMD]<>"\""]


Options[FDot]={Run->True};


IdentityMatrixQ=#===IdentityMatrix[Length@#]&;


FDot[m__?MatrixQ,OptionsPattern[]]:=Module[{
n,
ms={m},
subs,v,
str,fs,
res,
debug},
(*=========================== check input ===========================*)
If[!canmult[Dimensions/@ms],Return[$Failed]];
ms={m};(*debug=First@Timing[ms=DeleteCases[{m},_?IdentityMatrixQ];];
If[debug>10^-2,Print["Removing identity matrices took ",debug]];*)
n=Length@ms;
If[n==1,Return[First@ms]];(*nothing to multiply*)
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,Variables[ms]];
str="
; variables===========================
"<>var2str[Last/@subs]<>"
; matrix===========================
"<>StringRiffle[MapIndexed[mat2str[#1/.subs,"m"<>ToString[First@#2]]&,ms],"\n"]<>"
; command===========================
[m]:="<>StringRiffle["[m"<>ToString[#1]<>"]"&/@Range[n],"*"]<>";
; clean up===========================
@("<>StringRiffle["[m"<>ToString[#1]<>"]"&/@Range[n],","]<>");";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
res=Hold[str2mat[fs[#],"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.#2]&[str,(Reverse/@subs)];
If[!TrueQ[OptionValue[Run]],Return[res/.fs->(FermatSession@*ReadString)]];
res=ReleaseHold[res/.fs->Identity];
res
]


FDotBig::usage="FDotBig[A,B,C,\[Ellipsis]] multiplies the matrices splitting them, if necessary, into blocks. This is to overcome the restriction of Fermat for the ordinary matrices to have not more than 1000000 elements. The block size is given by the option \!\(\*
StyleBox[\"Block\",\nFontWeight->\"Bold\"]\).";


Options[FDotBig]={Block->1000};


FDotBig[matrices__?MatrixQ,OptionsPattern[]]:=Module[{bmatrices,identity,fdot,sz},
sz=OptionValue[Block];
bmatrices=Map[identity,System`PartitionWithRemainder[#,{sz,sz}],{2}]&/@{matrices};
(*dims=Dimensions[#,2]&/@bmatrices;*)
SetAttributes[fdot,Flat];
fdot[a___,b_Plus,c___]:=fdot[a,#,c]&/@b;
ArrayFlatten[Fold[Inner[fdot,##,Plus]&,bmatrices]/.identity->Identity/.fdot->FDot]
]


todo["Implement FAddBig in a manner similar to FDotBig."];


Options[FPlus]={Run->True};


FPlus[m__?MatrixQ,OptionsPattern[]]:=Module[{
n,
ms={m},
subs,v,
str,
res},
(*=========================== check input ===========================*)
n=Length@ms;
If[n==1,Return[ms[[1]]]];(*nothing to multiply*)
If[!SameQ@@(Dimensions/@ms),Return[$Failed]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,Variables[ms]];
str="
; variables===========================
"<>var2str[Last/@subs]<>"
; matrix===========================
"<>StringRiffle[MapIndexed[mat2str[#1/.subs,"m"<>ToString[First@#2]]&,ms],"\n"]<>"
; command===========================
[m]:="<>StringRiffle["[m"<>ToString[#1]<>"]"&/@Range[n],"+"]<>";
; clean up===========================
@("<>StringRiffle["[m"<>ToString[#1]<>"]"&/@Range[n],","]<>");";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2mat[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FDet]={Run->True};


FDet[m_?SquareMatrixQ,OptionsPattern[]]:=Module[{
l=Length@m,
subs=Variables[m],v,i,
str,
res},
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Return[Inverse[m]]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str="
; variables===========================
"<>var2str[Last/@subs]<>
"
; matrix===========================
"<>mat2str[m/.subs,"m"]<>"

; command===========================
det := Det([m]);

; clean up===========================
@([m]);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];(*=========================== Postprocess ===========================*)
res=str2scl[str,"det",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FInverse]={Run->True};


FInverse[m_?SquareMatrixQ,OptionsPattern[]]:=Module[{
l=Length@m,
subs=Variables[m],v,
str,
res},
(*=========================== check input ===========================*)
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Abort[]];
(*=========================== fermat input string ===========================*)
	(*make substitutions*)
subs=MapIndexed[#->(v@@#2)&,subs];
str="
; variables===========================
"<>var2str[Last/@subs]<>
"
; matrix===========================
"<>mat2str[m/.subs,"m"]<>"\[IndentingNewLine]
; command===========================
[mi]:=[m]^-1;

; clean up===========================
@([m]);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2mat[str,"mi",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FInverse[ms:{__?SquareMatrixQ},OptionsPattern[]]:=Module[{
l,v,subs,sub,strs,str,res},
(*=========================== check input ===========================*)
If[Not[FreeQ[ms,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Abort[]];
(*=========================== fermat input string ===========================*)
	(*make substitutions*)
{strs,subs}=Transpose[Function[m,
l=Length@m;sub=MapIndexed[#->(v@@#2)&,Variables[m]];str="\n; variables===========================\n"<>var2str[Last/@sub]<>"\n; matrix===========================\n"<>mat2str[m/.sub,"m"]<>"\n\n; command===========================\n[mi]:=[m]^-1;\n\n; clean up===========================\n@([m]);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
{str,sub}
]/@ms];
(*=========================== Run through Fermat ===========================*)
strs=FermatSession[strs,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[strs]];
(*=========================== Postprocess ===========================*)
res=MapThread[(str2mat[#,"mi",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@#2))&,{strs,subs}];
res
]


Options[FTransform]={Run->True};


FTransform[m_?SquareMatrixQ,t_?SquareMatrixQ,x_Symbol:0,OptionsPattern[]]:=Module[{
l=Length[m],
subs=Variables[{m,t}],v,i,
str,
templ,file,
res},
(*=========================== check input ===========================*)
If[l!=Length[t],Message[Dot::dotsh,m,t];Return[$Failed]];
If[Not[FreeQ[{m,t},_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FTransform.fer"];
Check[templ=ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<l>>"->ToString[l],"<<M>>"->imat2str[m/.subs],"<<T>>"->imat2str[t/.subs],"<<x>>"->ToString[x/.subs]}];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2mat[str,"mt",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FQuolyMod]={Run->True};


FQuolyMod[quoly_,poly_,x_Symbol,OptionsPattern[]]:=Module[{
subs=Append[DeleteCases[Variables[{quoly,poly}],x],x],
v,i,
str,
templ,file,
res},
(*=========================== check input ===========================*)
If[Not[FreeQ[{quoly,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=var2str[Last/@subs]<>"
quoly := "<>ToString[quoly/.subs,InputForm]<>";
poly := "<>ToString[poly/.subs,InputForm]<>";
quoly := QuolyMod(quoly,poly);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
If[!OptionValue[Run],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2scl[str,"quoly",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FQuolyMod[m_?MatrixQ,poly_,x_Symbol,OptionsPattern[]]:=Module[{
r,c,
subs=Append[DeleteCases[Variables[{m,poly}],x],x],
v,i,
str,
templ,file,
res},
{r,c}=Dimensions[m];
(*=========================== check input ===========================*)
If[Not[FreeQ[{m,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FQuolyMod.fer"];
Check[templ="\n\n"<>ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<r>>"->ToString[r],"<<c>>"->ToString[c],"<<M>>"->imat2str[m/.subs],"<<poly>>"->ToString[poly/.subs,InputForm]}];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
If[!TrueQ[OptionValue[Run]],Return[str]];res=str2mat[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FQuolyMod[ex_,x_Symbol->poly_,opts:OptionsPattern[]]:=FQuolyMod[ex,poly,x,opts]
FQuolyMod[ex_,list_List,opts:OptionsPattern[]]:=Fold[FQuolyMod[#1,#2,opts]&,ex,list]


todo["Redefine FPolyLeadingTerm for matrices."];


FPolyLeadingTerm::usage="FPolyLeadingTerm[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the result of the form \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"k\", \"TI\"]\) is the \"leading order\" and \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is the \"remainder\", such that \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)(\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"\[CenterDot]\", \"TI\"]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is a rational function with denominator being mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


Options[FPolyLeadingTerm]={Run->True};


FPolyLeadingTerm[quoly_,poly_,x_Symbol,OptionsPattern[]]:=Module[{
subs=Append[DeleteCases[Variables[{quoly,poly}],x],x],
v,i,
str,
templ,file,
res},
(*=========================== check input ===========================*)
If[Not[FreeQ[{quoly,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=var2str[Last/@subs]<>"
quoly := "<>ToString[quoly/.subs,InputForm]<>";
poly := "<>ToString[poly/.subs,InputForm]<>";
quoly := LQMTerm(quoly,poly);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
If[!OptionValue[Run],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2scl[str,"quoly",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FPolyLeadingTerm[m_?MatrixQ,poly_,x_Symbol,OptionsPattern[]]:=Module[{
r,c,
subs=Append[DeleteCases[Variables[{m,poly}],x],x],
v,i,
str,
templ,file,
res},
{r,c}=Dimensions[m];
(*=========================== check input ===========================*)
If[Not[FreeQ[{m,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FPolyLeadingTerm.fer"];
Check[templ="\n\n"<>ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<r>>"->ToString[r],"<<c>>"->ToString[c],"<<M>>"->imat2str[m/.subs],"<<poly>>"->ToString[poly/.subs,InputForm]}];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
If[!TrueQ[OptionValue[Run]],Return[str]];res=str2mat[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FPolyLeadingOrder::usage="FPolyLeadingOrder[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the \"leading order\"  \!\(\*
StyleBox[\"k\", \"TI\"]\) such that, \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where both the numerator and denominator of \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) are mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


Options[FPolyLeadingOrder]={Run->True};


FPolyLeadingOrder[quoly_,poly_,x_Symbol,OptionsPattern[]]:=Module[{
subs=Append[DeleteCases[Variables[{quoly,poly}],x],x],
v,i,
str,
templ,file,
res},
(*=========================== check input ===========================*)
If[Not[FreeQ[{quoly,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=var2str[Last/@subs]<>"
quoly := "<>ToString[quoly/.subs,InputForm]<>";
poly := "<>ToString[poly/.subs,InputForm]<>";
quoly := LQMOrder(quoly,poly);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
If[!OptionValue[Run],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2scl[str,"quoly",{"infty":>"Infinity","v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FPolyLeadingOrder[m_?MatrixQ,poly_,x_Symbol,OptionsPattern[]]:=Module[{
r,c,
subs=Append[DeleteCases[Variables[{m,poly}],x],x],
v,i,
str,
templ,file,
res},
{r,c}=Dimensions[m];
(*=========================== check input ===========================*)
If[Not[FreeQ[{m,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FPolyLeadingOrder.fer"];
Check[templ="\n\n"<>ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<r>>"->ToString[r],"<<c>>"->ToString[c],"<<M>>"->imat2str[m/.subs],"<<poly>>"->ToString[poly/.subs,InputForm]}];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
If[!TrueQ[OptionValue[Run]],Return[str]];res=str2scl[str,"k",{"infty":>"Infinity","v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FNormalize]={Run->True};


FNormalize[m_?SquareMatrixQ,OptionsPattern[]]:=Module[{
l=Length@m,
subs=Variables[m],v,
str,
a,b,c,d,r},
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Return[Inverse[m]]];
(*=========================== Write input file ===========================*)
	(*make substitutions*)
subs=MapIndexed[#->(v@@#2)&,subs];
str="
; variables===========================
"<>var2str[Last/@subs]<>"

; matrix===========================
"<>mat2str[m/.subs,"m"]<>"

; command===========================
Normalize([m],[a],[b],[c],[d]);

; clean up===========================
";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
r=str2mat[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
a=str2mat[str,"a",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
b=str2mat[str,"b",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
c=str2mat[str,"c",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
d=str2mat[str,"d",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
{a,b,c,d,r}
]


todo["inplement Colreduce similarly to Normalize"];


Options[FKer]={Run->True};


FKer[m_?MatrixQ,OptionsPattern[]]:=Module[{
r,c,
subs=Variables[m],v,
str,
templ,file,
res},
{r,c}=Dimensions[m];
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FKer.fer"];
Check[templ=ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== Write input file ===========================*)
	(*make substitutions*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<rows>>"->ToString[r],"<<cols>>"->ToString[c],"<<matr>>"->imat2str[m/.subs]}],(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)res=str2mat[str,"ns",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
Transpose[res]
]


FRowEchelon::usage ="FRowEchelon[\!\(\*
StyleBox[\"m\", \"TI\"]\)] gives the row-reduced form of the matrix \!\(\*
StyleBox[\"m\", \"TI\"]\).";


Options[FRowEchelon]={Run->True,Reduce->False};
FRowEchelon[m_?MatrixQ,OptionsPattern[]]:=Module[{
mt,vs,
v,subs,
str,res,
monbuf,monpr=0,monl=1,monf,monr=False,mont},
monf=If[monr,mont=StringCases[#3,x:(DigitCharacter..):>ToExpression[x]];If[mont=!={},monpr=Last@mont];"",
If[MatchQ[{#1,#3},{_String,_String}],mont=StringCases[#3,"Sparse reduce row echelon, cols "~~(x:DigitCharacter..):>ToExpression[x]];
If[mont=!={},monl=Last@mont;monr=True];#1<>#3,#1]]&;
mt=ArrayRules[m];
vs=Variables[Last/@mt];
subs=MapIndexed[#->(v@@#2)&,vs];
str="
; variables =========================
"<>var2str[Last/@subs]<>
"
; matrix ============================
"<>smat2str[SparseArray[mt/.subs,Dimensions[m]],"m"]<>"
; turn on dislay====================
&V;
; command ===========================
R"<>If[OptionValue[Reduce],"edr",""]<>"owech([m]);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
monbuf="";
Monitor[
str=FermatSession[str,monbuf,monf,Run->OptionValue[Run]],
ProgressIndicator[monpr,{0,monl}]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=SparseArray[Flatten[Function[row,{row[[1]],#1}->#2&@@@Rest[row]]/@str2sarr[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs)],Dimensions@m];
res
]


FGaussSolve::usage ="FGaussSolve[eqs,vars] solves homogeneous linear equations.";
FGaussSolve::notimplemented ="Sorry, not implemented. Aborting...";


Options[FGaussSolve]={Run->True,Reduce->True};
FGaussSolve[eqs_,vars_,OptionsPattern[]]:=Module[{
m,rvars=Reverse[vars],u=0,
v,subs,
str,res,
monbuf,monpr=0,monpr1=-1,monl=1,monf,monr=False,mont},
If[eqs==={},Return[{}]];
monf=If[monr,mont=StringCases[#3,x:(DigitCharacter..):>ToExpression[x]];If[mont=!={},monpr=Last@mont;CProgressPrint[monpr1,monpr,monl]];"",
If[MatchQ[{#1,#3},{_String,_String}],mont=StringCases[#3,"Sparse reduce row echelon, cols "~~(x:DigitCharacter..):>ToExpression[x]];
If[mont=!={},monl=Last@mont;monr=True];#1<>#3,#1]]&;
m=CoefficientArrays[eqs,rvars];
(*=========================== check input ===========================*)
If[Not[FreeQ[m,_Complex]],Message[FGaussSolve::notimplemented];Abort[]];
If[Length[m]=!=2,Message[FGaussSolve::notimplemented];Abort[]];
If[Length[ArrayRules[First[m]]]>1,
Message[FGaussSolve::notimplemented];Abort[]];
(*=========================== fermat input string ===========================*)
	(*make substitutions*)
m=ArrayRules[Last[m]];
subs=MapIndexed[#->(v@@#2)&,Variables[Last/@m]];
(*CPrint["Pivoting: &(u="<>ToString[u]<>");"];*)
str="
; variables =========================
"<>var2str[Last/@subs]<>
"
; matrix ============================
"<>smat2str[SparseArray[m/.subs,{Length@eqs,Length@vars}],"m"]<>"
; turn on dislay====================
&V;
; choose pivoting strategy
&(u="<>ToString[u]<>");
; command ===========================
R"<>If[OptionValue[Reduce],"edr",""]<>"owech([m]);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
monbuf="";monl=Length@vars;
CMonitor[
str=FermatSession[str,monbuf,monf,Run->OptionValue[Run]],
Overlay[{ProgressIndicator[monpr,{0,monl}],"GS:"<>ToString[monpr]<>"/"<>ToString[monl]},Alignment->Center],1];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=First[#][[1]]->-1/First[#][[2]] Plus@@Times@@@Rest[#]&/@
MapAt[rvars[[#]]&,(Rest/@str2sarr[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs)),{All,All,1}];
res
]


Options[FTogether]={Run->True};


FTogether::usage="FTogether[m_?MatrixQ] simply reads in the matrix and writes back. Since Fermat automatically makes \"Together\" we have what we want."


FTogether[s:Except[_List],opts:OptionsPattern[]]:=FTogether[{{s}},opts][[1,1]]
FTogether[v_?VectorQ,opts:OptionsPattern[]]:=First[FTogether[{v},opts]]


FTogether[m_?MatrixQ,OptionsPattern[]]:=Module[{
subs,v,
str,fs,
res},
(*=========================== check input ===========================*)
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,Variables[m]];
str="
; variables===========================
"<>var2str[Last/@subs]<>"
; matrix===========================
"<>mat2str[m/.subs,"m"]<>"
;";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
res=Hold[str2mat[fs[#],"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.#2]&[str,(Reverse/@subs)];
If[!TrueQ[OptionValue[Run]],Return[res/.fs->(FermatSession@*ReadString)]];
res=ReleaseHold[res/.fs->Identity];
res
]


FermatSession::fail="Something went wrong when invoking fermat with \"`1`\". Setting variable $FermatCMD to different value might help.";


todo["check that FermatSession works better (changed termination criterion)"];


FermatSession::switches="&_t;";


SetAttributes[FermatSession,HoldRest];


Options[FermatSession]:={
Run->True,
Background->False,(*whether to run in Background*)
DeleteFile->True,
In->Automatic,
Out->Automatic,
LibraryLoad->{}
};


Module[{dummy},
FermatSession[str_String,monitor_Symbol:dummy,mfunc:Except[_Rule|_RuleDelayed]:(#2&),opts:OptionsPattern[]]:=
Module[
{in,out,res,delay},
If[!MatchQ[$FermatCMD,_String],Print["To use Fermat CAS, set $FermatCMD to the fermat executable full path with\n    $FermatCMD=\"path/to/fer64\";\nAlternatively, you may set the system environment variable FERMATPATH to the same path."];Return[$Failed]];
{in,out}=PrepareInOut[str,FilterRules[{opts},Options[PrepareInOut]]];
If[!OptionValue[Run],Return[in]];
ParallelRun[{{in,out}},{monitor},mfunc[#1,#2,#3]&];
If[OptionValue[DeleteFile],
res=ReadString[out,EndOfFile];DeleteFile[{in,out}],
res=out;DeleteFile[in];
];
res
];
FermatSession[strs:{__String},monitor_Symbol:dummy,mfunc:Except[_Rule|_RuleDelayed]:(#2&),opts:OptionsPattern[]]:=
Module[
{inouts,res,delay},
If[!MatchQ[$FermatCMD,_String],Print["To use Fermat CAS, set $FermatCMD to the fermat executable full path with\n    $FermatCMD=\"path/to/fer64\";\nAlternatively, you may set the system environment variable FERMATPATH to the same path."];Return[$Failed]];
inouts=PrepareInOut[#,FilterRules[{opts},Options[PrepareInOut]]]&/@strs;
If[!OptionValue[Run],Return[First/@inouts]];

ParallelRun[inouts,monitor,mfunc];
If[OptionValue[DeleteFile],
res=ReadString[Last@#,EndOfFile]&/@inouts;DeleteFile[Flatten[inouts]],
res=Last/@inouts;DeleteFile[First/@inouts];
];
res
]
];


Options[PrepareInOut]:=Thread[{In,Out,LibraryLoad}->({In,Out,LibraryLoad}/.Options[FermatSession])];


PrepareInOut[str_String,OptionsPattern[]]:=Module[
{file,
in,
out},
If[str==="",Print["Fermatica`Private`PrepareInOut: zero string received"];Abort[]];
in=Replace[OptionValue[In],Automatic:>uniquefile["in"]];
file=OpenWrite[in];
out=Replace[OptionValue[Out],Automatic:>uniquefile["out"]];
Close[OpenWrite[out]];(*\[DoubleLongLeftArrow] reserve output file*)
WriteString[file,ReadString[#]]&/@OptionValue[LibraryLoad];
WriteString[file,FermatSession::switches<>"\n"<>str<>"\n&(S='"<>out<>"');\n&s;\n&q;\n&x;"];
Close[file];
Return[{in,out}]
]


SetAttributes[ParallelRun,HoldRest];


Module[{dummy},
ParallelRun[inouts:{{_String,_String}..},monitors:(_Symbol|_List):dummy,mfunc:Except[_Rule|_RuleDelayed]:(#2&)]:=Module[
{ins=First/@inouts,n,fcommands,logs,fermats,buffers,new,line,p,error=False,cleanup,delay=2^-20},
fcommands=StringRiffle[(FileNameTake@ToString[$FermatCMD]<>" <"<>FileNameTake@#1<>" >"<>FileNameTake@#2<>"")&@@@inouts,"\n"];
n=Length@ins;
cleanup=(Quiet[Outer[Close@*ProcessConnection,#,{"StandardInput","StandardOutput","StandardError"}]];KillProcess/@#)&;
CStaticMonitor[CheckAbort[
(*start fermat workers*)
Check[fermats=Table[StartProcess[$FermatCMD],{n}],Message[FermatSession::fail,$FermatCMD];cleanup[fermats];(*DeleteFile[Flatten[inouts]];*)
Abort[]];
(*prepare buffers*)
buffers=ConstantArray["",n];
logs=ConstantArray[{},n];
(*load in files fermat workers*)
MapThread[WriteLine[#1,"&(R='"<>#2<>"');"]&,{fermats,ins}];
While[AnyTrue[fermats,ProcessStatus[#]==="Running"&],
Pause[delay];If[delay<1,delay=2*delay];
Do[new=ReadString[fermats[[i]],EndOfBuffer];(*read to the end of the bufer*)
(*Modified 25.05.2020*)Switch[new,
EndOfFile|EndOfBuffer,Null,
_,buffers[[i]]=buffers[[i]]<>new;
line="";
While[line=!=EndOfFile,
If[{}===(p=StringPosition[buffers[[i]],"\n",1]),line=EndOfFile,line=StringTake[buffers[[i]],p[[1,1]]-1];buffers[[i]]=StringDrop[buffers[[i]],p[[1,2]]]];
If[line=!=EndOfFile,
If[StringMatchQ[line,(StartOfString~~"\\*\\*\\*"~~__)],
logs[[i]]=Append[logs[[i]],Style[line,Red]];
error=True
,
logs[[i]]=Append[logs[[i]],line];
If[StringMatchQ[line,"*>"]&&error,Print[Sequence@@(Style[#,Small]&/@Riffle[logs[[i]],"\n"])];
cleanup[];Abort[]]]
];
If[Head[Unevaluated[monitors]]===List,
(#=mfunc[Evaluate[#],Replace[line,EndOfFile->""],new])&[ReleaseHold[Map[Unevaluated,Hold[monitors],{2}]][[i]]],
monitors[[i]]=mfunc[monitors[[i]],Replace[line,EndOfFile->""],new]]
]]
,{i,n}]
],

cleanup[fermats];Abort[]],fcommands,1];
cleanup[fermats];
]
];


FermatDetachedSession::fail="Something went wrong when invoking fermat with \"`1`\". Setting variable $FermatCMD to different value might help.";


todo["check that FermatDetachedSession works"];


FermatDetachedSession::switches="&_t;";


Options[FermatDetachedSession]:={Run->True,In->Automatic,Out->Automatic,LibraryLoad->{}};


FermatDetachedSession[str_String,OptionsPattern[]]:=Module[
{file,
in=Replace[OptionValue[In],Automatic:>uniquefile["in"]],
out=Replace[OptionValue[Out],Automatic:>uniquefile["out"]],
fer,log={},line,error=False,
cleanup,res},
cleanup=(Quiet[DeleteFile[in];DeleteFile[out]];
KillProcess[fer,15];
If[ProcessStatus[fer]!="Finished",WriteLine[fer,"&q;"]])&;
file=OpenWrite[in];
WriteString[file,FermatDetachedSession::switches<>"\n\n!!('Input: "<>in<>"');\n\n"<>str<>"
&(S='"<>out<>"');
&s;
!!('Output: "<>out<>"');
&q;
&x;"];
Close[file];
If[!OptionValue[Run],Return[in]];
Check[fer=StartProcess[$FermatCMD],Message[FermatDetachedSession::fail,$FermatCMD]];
WriteLine[fer,"&(R='"<>#<>"');"]&/@OptionValue[LibraryLoad];
WriteLine[fer,"&(R='"<>in<>"');"];
fer
];


GetOutput[fer_]:=Module[{stdout,out},
If[ProcessStatus[fer]=="Running",Return[$Failed]];stdout=ReadString[fer,EndOfBuffer];
out=First@StringCases[stdout,RegularExpression["Output: (.+)"]:>"$1"];
ReadString[out,EndOfFile]
]


GetInput[fer_]:=Module[{stdout,in},
If[ProcessStatus[fer]=="Running",Return[$Failed]];stdout=ReadString[fer,EndOfBuffer];
in=First@StringCases[stdout,RegularExpression["Input: (.+)"]:>"$1"];
ReadString[in,EndOfFile]
]


fermatspecials={"&_n":>"",a1:DigitCharacter~~" "~~a2:DigitCharacter:>a1<>a2};


uniquefile[s_String]:=Module[{i=1,fn},While[FileExistsQ[fn=$FermatTempDir<>s<>ToString[i]],i++];fn]


mat2str::usage="mat2str[smat] coverts Mathematica matrix to Fermat sparse array"
imat2str[m_]:=StringRiffle[Map["    "<>ToString[#,InputForm]&,Transpose[m],{2}],",\n\n",",\n"];
mat2str[m_,mn_String]:=Module[{l=StringRiffle[ToString/@Dimensions[m],","]},"Array "<>mn<>"["<>l<>"];\n["<>mn<>"] := [(\n"<>imat2str[m]<>"\n)];"]


smat2str::usage="smat2str[smat] coverts Mathematica sparse matrix to Fermat sparse array";
smat2str[smat_,nm_String]:=Module[{r,c},{r,c}=Dimensions[smat];"Array "<>nm<>"["<>ToString[r]<>","<>ToString[c]<>"] Sparse;\n["<>nm<>"] := "<>ismat2str[smat]<>";"];
ismat2str[smat_]:=iarules2str[Most@ArrayRules@smat];
iarules2str[{}]:="[ ]";
iarules2str[arules_]:="[ "<>StringRiffle[StringReplace[ToString[Flatten[#/.Rule->List,1],InputForm]&/@MapAt[Last,GroupBy[SortBy[arules,First],First@*First]/.Association->List,{All,2,All,1}],{"{"->"[ ","}"->"] "}],"\n"]<>"]"


var2str=StringRiffle["  &(J="<>ToString[#]<>");"&/@#,"\n"]&;


str2scl[stream_,sn_String,rule_List:{}]:=Module[{s,e,r,c,start},
s=First@StringPosition[stream,"\n "<>sn<>" := ",1];
e=Last[s]+First@StringPosition[StringDrop[stream,Last[s]],";",1];
ToExpression[StringReplace[StringTake[stream,{Last[s]+1,First[e]-1}],Join[rule,fermatspecials]]]
];


str2mat[stream_,mn_String,rule_List:{}]:=Module[{s,e,r,c,start},
s=First@StringPosition[stream,("\nArray "<>mn<>"[")~~(DigitCharacter..)~~","~~(DigitCharacter..)~~"];\n["<>mn<>"] := ["~~("("|"["),1];
e=Last[s]+First@StringPosition[StringDrop[stream,Last[s]],(")"|"]")~~"];",1];
start=StringTake[stream,s];
{r,c}=First@StringCases[start,"["~~r:(DigitCharacter..)~~","~~c:(DigitCharacter..)~~"]":>ToExpression["{"<>r<>","<>c<>"}"]];
If[StringTake[start,-1]=="(",Transpose@Partition[#,r],Partition[#,c]]&[ToExpression["{"<>StringReplace[StringTake[stream,{Last[s]+1,First[e]-1}],Join[rule,fermatspecials]]<>"}"]]
];


str2smat[stream_,mn_String,rule_List:{}]:=SparseArray[Flatten[Function[r,{r[[1]],#1}->#2&@@@r[[2;;]]]/@str2sarr[stream,mn,rule]]];


str2sarr[stream_,mn_String,rule_List:{}]:=Module[{s,e,r,c,start},
s=First@StringPosition[stream,("\nArray "<>mn<>"[")~~(DigitCharacter..)~~","~~(DigitCharacter..)~~"] Sparse;\n["<>mn<>"] := [",1];
e=Last[s]+First@StringPosition[StringDrop[stream,Last[s]],"];",1];
start=StringTake[stream,s];
{r,c}=First@StringCases[start,"["~~r:(DigitCharacter..)~~","~~c:(DigitCharacter..)~~"]":>ToExpression["{"<>r<>","<>c<>"}"]];
ToExpression[Fold[StringReplace,StringTake[stream,{Last[s],First[e]}],{{"\n"->""},{"]"~~(" "...)~~"["->"], ["},{"["->"{","]"->"}"},fermatspecials,rule}]]
]


canmult=MatchQ[#,{{_,_}..}]&&MatchQ[DeleteDuplicates/@Partition[Take[Flatten[#],{2,-2}],2],{{_}...}]&;


If[NameQ["Global`$FermaticaTODO"]&&Symbol["Global`$FermaticaTODO"],
Print["TODO list:"];
Print[Style["\[FilledSmallCircle] "<>#,{"Text",Small}]]&/@todolist];


End[];


EndPackage[]



