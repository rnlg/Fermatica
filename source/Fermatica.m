(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["Fermatica`"]


$FermatCMD=Environment["FERMATPATH"];


$FermatTempDir="/dev/shm/";


FermatDetachedSession;GetOutput;GetInput;
FermatSession;
FDot;
FDotBig;
FPlus;
FInverse;
FTransform;
FDet;
FNormalize;
FKer;
FQuolyMod;
FPolyLeadingTerm;FPolyLeadingOrder;
FGaussSolve;


$FermaticaHomeDirectory=DirectoryName[$InputFileName];


$FermaticaVersion="1.00";


System`PartitionWithRemainder::usage="PartitionWithRemainder[list,size] does the same as Partition[list,size], but does not omit the trailing elements if the chunk size does not divide list length.\nE.g. PartitionWithRemainder[{a,b,c,d,e,f,g,h},3] yields {{a,b,c},{d,e,f},{g,h}}.\n Works also for multidimensional arrays.";
System`PartitionWithRemainder=(Partition[#1,#2,#2,If[Length[#2]>1,{1,1}&/@#2,{1,1}],{}]//.{}:>Sequence[])&;


Begin["`Private`"]


todolist={};
todo[s_String]:=AppendTo[todolist,s];


todo["write *::usage for each command"];


todo["make FGaussSolve work correctly with inhomogeneous equations. Or at least, detect them."]


todo["adjust Fermatica to batch run. Run\[Rule]False option is not sufficient as it does not save the information about the Mathematica names of the variables."];


todo["Prevent printing huge Fermat output at error"];


SetAttributes[FCStaticMonitor,{HoldAll}];
FCStaticMonitor[code_,msg_String,delay_:0]:=If[$Notebooks,
Monitor[code,msg,delay],
WriteString["stdout","\n["<>msg];(WriteString["stdout","]"];#)&[code]
];


SetAttributes[FCMonitor,{HoldAll}];
FCMonitor[code_,mon_,delay_:0,msg_String:""]:=If[$Notebooks,
Monitor[code,mon,delay],
If[msg=!="",WriteString["stdout","\n["<>msg]];(If[msg=!="",WriteString["stdout","]"]];#)&[code]
];


FCPrint[ex__]:=If[$Notebooks,Print[ex],Print@@(ToString/@{ex})];
FCPrintTemporary[ex__]:=If[$Notebooks,PrintTemporary[ex]];


FCPrint["\n******************** ",Style["Fermatica v"<>ToString[$FermaticaVersion],{Bold}]," ********************\n\
Inteface to ",Hyperlink["Fermat CAS", "http://home.bway.net/lewis/"],".\nWritten by Roman N. Lee in 2018.\nRead from: "<>$InputFileName<>"\nMD5: "<>ToString[FileHash[$InputFileName,"MD5"]]]


FCPrint[ex__]:=If[$Notebooks,Print[ex],Print@@(ToString/@{ex})];


FCPrint["$FermatCMD is set to \""<>ToString[$FermatCMD]<>"\""];


Options[FDot]={Run->True};


FDot[m__?MatrixQ,OptionsPattern[]]:=Module[{
n,
ms={m},
subs,v,
str,fs,
res},
(*=========================== check input ===========================*)
n=Length@ms;
If[n==1,Return[ms[[1]]]];(*nothing to multiply*)
If[!canmult[Dimensions/@ms],Return[$Failed]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,Variables[ms]];
str="
; variables===========================
"<>var2str[Last/@subs]<>"
; matrix===========================
"<>StringRiffle[MapIndexed[mat2str[#1/.subs,"m"<>ToString[First@#2]]&,ms],"\n"]<>"
; command===========================
[m]:="<>StringRiffle["[m"<>ToString[#1]<>"]"&/@Range[n],"*"]<>";
; clean up===========================
@("<>StringRiffle["[m"<>ToString[#1]<>"]"&/@Range[n],","]<>");";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
res=Hold[str2mat[fs[#],"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.#2]&[str,(Reverse/@subs)];
If[!TrueQ[OptionValue[Run]],Return[res/.fs->(FermatSession@*ReadString)]];
res=ReleaseHold[res/.fs->Identity];
res
]


FDotBig::usage="FDotBig[A,B,C,\[Ellipsis]] multiplies the matrices splitting them, if necessary, into blocks. This is to overcome the restriction of Fermat for the ordinary matrices to have not more than 1000000 elements. The block size is given by the option \!\(\*
StyleBox[\"Block\",\nFontWeight->\"Bold\"]\).";


Options[FDotBig]={Block->1000};


FDotBig[matrices__?MatrixQ,OptionsPattern[]]:=Module[{bmatrices,identity,fdot,sz},
sz=OptionValue[Block];
bmatrices=Map[identity,System`PartitionWithRemainder[#,{sz,sz}],{2}]&/@{matrices};
(*dims=Dimensions[#,2]&/@bmatrices;*)
SetAttributes[fdot,Flat];
fdot[a___,b_Plus,c___]:=fdot[a,#,c]&/@b;
ArrayFlatten[Fold[Inner[fdot,##,Plus]&,bmatrices]/.identity->Identity/.fdot->FDot]
]


todo["Implement FAddBig in a manner similar to FDotBig."];


Options[FPlus]={Run->True};


FPlus[m__?MatrixQ,OptionsPattern[]]:=Module[{
n,
ms={m},
subs,v,
str,
res},
(*=========================== check input ===========================*)
n=Length@ms;
If[n==1,Return[ms[[1]]]];(*nothing to multiply*)
If[!SameQ@@(Dimensions/@ms),Return[$Failed]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,Variables[ms]];
str="
; variables===========================
"<>var2str[Last/@subs]<>"
; matrix===========================
"<>StringRiffle[MapIndexed[mat2str[#1/.subs,"m"<>ToString[First@#2]]&,ms],"\n"]<>"
; command===========================
[m]:="<>StringRiffle["[m"<>ToString[#1]<>"]"&/@Range[n],"+"]<>";
; clean up===========================
@("<>StringRiffle["[m"<>ToString[#1]<>"]"&/@Range[n],","]<>");";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2mat[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FDet]={Run->True};


FDet[m_?SquareMatrixQ,OptionsPattern[]]:=Module[{
l=Length@m,
subs=Variables[m],v,i,
str,
res},
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Return[Inverse[m]]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str="
; variables===========================
"<>var2str[Last/@subs]<>
"
; matrix===========================
"<>mat2str[m/.subs,"m"]<>"

; command===========================
det := Det([m]);

; clean up===========================
@([m]);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];(*=========================== Postprocess ===========================*)
res=str2scl[str,"det",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FInverse]={Run->True};


FInverse[m_?SquareMatrixQ,OptionsPattern[]]:=Module[{
l=Length@m,
subs=Variables[m],v,
str,
res},
(*=========================== check input ===========================*)
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Abort[]];
(*=========================== fermat input string ===========================*)
	(*make substitutions*)
subs=MapIndexed[#->(v@@#2)&,subs];
str="
; variables===========================
"<>var2str[Last/@subs]<>
"
; matrix===========================
"<>mat2str[m/.subs,"m"]<>"\[IndentingNewLine]
; command===========================
[mi]:=[m]^-1;

; clean up===========================
@([m]);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2mat[str,"mi",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FTransform]={Run->True};


FTransform[m_?SquareMatrixQ,t_?SquareMatrixQ,x_Symbol:0,OptionsPattern[]]:=Module[{
l=Length[m],
subs=Variables[{m,t}],v,i,
str,
templ,file,
res},
(*=========================== check input ===========================*)
If[l!=Length[t],Message[Dot::dotsh,m,t];Return[$Failed]];
If[Not[FreeQ[{m,t},_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FTransform.fer"];
Check[templ=ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<l>>"->ToString[l],"<<M>>"->imat2str[m/.subs],"<<T>>"->imat2str[t/.subs],"<<x>>"->ToString[x/.subs]}];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2mat[str,"mt",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FQuolyMod]={Run->True};


FQuolyMod[quoly_,poly_,x_Symbol,OptionsPattern[]]:=Module[{
subs=Append[DeleteCases[Variables[{quoly,poly}],x],x],
v,i,
str,
templ,file,
res},
(*=========================== check input ===========================*)
If[Not[FreeQ[{quoly,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=var2str[Last/@subs]<>"
quoly := "<>ToString[quoly/.subs,InputForm]<>";
poly := "<>ToString[poly/.subs,InputForm]<>";
quoly := QuolyMod(quoly,poly);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
If[!OptionValue[Run],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2scl[str,"quoly",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FQuolyMod[m_?MatrixQ,poly_,x_Symbol,OptionsPattern[]]:=Module[{
r,c,
subs=Append[DeleteCases[Variables[{m,poly}],x],x],
v,i,
str,
templ,file,
res},
{r,c}=Dimensions[m];
(*=========================== check input ===========================*)
If[Not[FreeQ[{m,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FQuolyMod.fer"];
Check[templ="\n\n"<>ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<r>>"->ToString[r],"<<c>>"->ToString[c],"<<M>>"->imat2str[m/.subs],"<<poly>>"->ToString[poly/.subs,InputForm]}];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
If[!TrueQ[OptionValue[Run]],Return[str]];res=str2mat[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


todo["Redefine FPolyLeadingTerm for matrices."];


FPolyLeadingTerm::usage="FPolyLeadingTerm[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the result of the form \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)(\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"k\", \"TI\"]\) is the \"leading order\" and \!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is the \"remainder\", such that \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)(\!\(\*
StyleBox[\"R\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"+\", \"TI\"]\)\!\(\*
StyleBox[\" \", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"\[CenterDot]\", \"TI\"]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) is a rational function with denominator being mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


Options[FPolyLeadingTerm]={Run->True};


FPolyLeadingTerm[quoly_,poly_,x_Symbol,OptionsPattern[]]:=Module[{
subs=Append[DeleteCases[Variables[{quoly,poly}],x],x],
v,i,
str,
templ,file,
res},
(*=========================== check input ===========================*)
If[Not[FreeQ[{quoly,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=var2str[Last/@subs]<>"
quoly := "<>ToString[quoly/.subs,InputForm]<>";
poly := "<>ToString[poly/.subs,InputForm]<>";
quoly := LQMTerm(quoly,poly);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
If[!OptionValue[Run],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2scl[str,"quoly",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FPolyLeadingTerm[m_?MatrixQ,poly_,x_Symbol,OptionsPattern[]]:=Module[{
r,c,
subs=Append[DeleteCases[Variables[{m,poly}],x],x],
v,i,
str,
templ,file,
res},
{r,c}=Dimensions[m];
(*=========================== check input ===========================*)
If[Not[FreeQ[{m,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FPolyLeadingTerm.fer"];
Check[templ="\n\n"<>ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<r>>"->ToString[r],"<<c>>"->ToString[c],"<<M>>"->imat2str[m/.subs],"<<poly>>"->ToString[poly/.subs,InputForm]}];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
If[!TrueQ[OptionValue[Run]],Return[str]];res=str2mat[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FPolyLeadingOrder::usage="FPolyLeadingOrder[\!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\)] gives the \"leading order\"  \!\(\*
StyleBox[\"k\", \"TI\"]\) such that, \!\(\*
StyleBox[\"Q\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\)\!\(\*
StyleBox[\"=\", \"TI\"]\)\!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*SuperscriptBox[
StyleBox[\")\", \"TI\"], \(k\)]\)\!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\), where both the numerator and denominator of \!\(\*
StyleBox[\"S\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\) are mutually simple with \!\(\*
StyleBox[\"P\", \"TI\"]\)\!\(\*
StyleBox[\"(\", \"TI\"]\)\!\(\*
StyleBox[\"x\", \"TI\"]\)\!\(\*
StyleBox[\")\", \"TI\"]\).";


Options[FPolyLeadingOrder]={Run->True};


FPolyLeadingOrder[quoly_,poly_,x_Symbol,OptionsPattern[]]:=Module[{
subs=Append[DeleteCases[Variables[{quoly,poly}],x],x],
v,i,
str,
templ,file,
res},
(*=========================== check input ===========================*)
If[Not[FreeQ[{quoly,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=var2str[Last/@subs]<>"
quoly := "<>ToString[quoly/.subs,InputForm]<>";
poly := "<>ToString[poly/.subs,InputForm]<>";
quoly := LQMOrder(quoly,poly);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
If[!OptionValue[Run],Return[str]];
(*=========================== Postprocess ===========================*)
res=str2scl[str,"quoly",{"infty":>"Infinity","v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


FPolyLeadingOrder[m_?MatrixQ,poly_,x_Symbol,OptionsPattern[]]:=Module[{
r,c,
subs=Append[DeleteCases[Variables[{m,poly}],x],x],
v,i,
str,
templ,file,
res},
{r,c}=Dimensions[m];
(*=========================== check input ===========================*)
If[Not[FreeQ[{m,poly},_Complex]],Print["Sorry, can not treat complex numbers."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FPolyLeadingOrder.fer"];
Check[templ="\n\n"<>ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== fermat input string ===========================*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<r>>"->ToString[r],"<<c>>"->ToString[c],"<<M>>"->imat2str[m/.subs],"<<poly>>"->ToString[poly/.subs,InputForm]}];
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,LibraryLoad->{$FermaticaHomeDirectory<>"snippets/ModTools.lib.fer"},Run->OptionValue[Run]];
(*=========================== Postprocess ===========================*)
If[!TrueQ[OptionValue[Run]],Return[str]];res=str2scl[str,"k",{"infty":>"Infinity","v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
res
]


Options[FNormalize]={Run->True};


FNormalize[m_?SquareMatrixQ,OptionsPattern[]]:=Module[{
l=Length@m,
subs=Variables[m],v,
str,
a,b,c,d,r},
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Return[Inverse[m]]];
(*=========================== Write input file ===========================*)
	(*make substitutions*)
subs=MapIndexed[#->(v@@#2)&,subs];
str="
; variables===========================
"<>var2str[Last/@subs]<>"

; matrix===========================
"<>mat2str[m/.subs,"m"]<>"

; command===========================
Normalize([m],[a],[b],[c],[d]);

; clean up===========================
";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
r=str2mat[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
a=str2mat[str,"a",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
b=str2mat[str,"b",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
c=str2mat[str,"c",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
d=str2mat[str,"d",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
{a,b,c,d,r}
]


todo["inplement Colreduce similarly to Normalize"];


Options[FKer]={Run->True};


FKer[m_?MatrixQ,OptionsPattern[]]:=Module[{
r,c,
subs=Variables[m],v,
str,
templ,file,
res},
{r,c}=Dimensions[m];
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Abort[]];
file=OpenRead[$FermaticaHomeDirectory<>"snippets/FKer.fer"];
Check[templ=ReadString[file,EndOfFile],Abort[]];
Close[file];
(*=========================== Write input file ===========================*)
	(*make substitutions*)
subs=MapIndexed[#->(v@@#2)&,subs];
str=StringReplace[StringReplace[templ,{"<<vars>>"->var2str[Last/@subs],"<<rows>>"->ToString[r],"<<cols>>"->ToString[c],"<<matr>>"->imat2str[m/.subs]}],(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)res=str2mat[str,"ns",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs);
Transpose[res]
]


FGaussSolve::usage ="FGaussSolve[eqs,vars] solves homogeneous linear equations.";
FGaussSolve::notimplemented ="FGaussSolve solves only homogeneous linear equations.";


Options[FGaussSolve]={Run->True,Reduce->False};
FGaussSolve[eqs_,vars_,OptionsPattern[]]:=Module[{
m,rvars=Reverse[vars],
v,subs,
str,
res},
m=CoefficientArrays[eqs,rvars];
If[Length[ArrayRules[First[m]]]>1||Length[m]=!=2,Message[FGaussSolve::notimplemented];Abort[]];
m=ArrayRules[Last[m]];
(*=========================== check input ===========================*)
If[Not[FreeQ[m,_Complex]],Print["Sorry, can not treat complex numbers in matrix."];Abort[]];
(*=========================== fermat input string ===========================*)
	(*make substitutions*)
subs=MapIndexed[#->(v@@#2)&,Variables[Last/@m]];
str="
; variables===========================
"<>var2str[Last/@subs]<>
"
; matrix===========================
"<>smat2str[SparseArray[m/.subs],"m"]<>"\[IndentingNewLine]
; command===========================
R"<>If[OptionValue[Reduce],"edr",""]<>"owech([m]);";
str=StringReplace[str,(ToString[v]<>"[")~~(n:DigitCharacter..)~~"]":>"v"<>n];
(*=========================== Run through Fermat ===========================*)
str=FermatSession[str,Run->OptionValue[Run]];
If[!TrueQ[OptionValue[Run]],Return[str]];
(*=========================== Postprocess ===========================*)
res=First[#][[1]]->-1/First[#][[2]] Plus@@Times@@@Rest[#]&/@
MapAt[rvars[[#]]&,(Rest/@str2sarr[str,"m",{"v"~~(n:DigitCharacter..):>(ToString[v]<>"[")<>n<>"]"}]/.(Reverse/@subs)),{All,All,1}];
res
]


FermatSession::fail="Something went wrong when invoking fermat with \"`1`\". Setting variable $FermatCMD to different value might help.";


todo["check that FermatSession works better (changed termination criterion)"];


FermatSession::switches="&_t;";


SetAttributes[FermatSession,HoldRest];


Options[FermatSession]:={
Run->True,
Background->False,(*whether to run in Background*)
DeleteFile->True,
In->Automatic,
Out->Automatic,
LibraryLoad->{}(*Library files to load*)
};


Module[{dummy},
FermatSession[str_String,monitor_Symbol:dummy,mfunc:Except[_Rule|_RuleDelayed]:(#2&),OptionsPattern[]]:=
Module[
{file,
in=Replace[OptionValue[In],Automatic:>uniquefile["in"]],
out=Replace[OptionValue[Out],Automatic:>uniquefile["out"]],
fer,log={},line,error=False,
cleanup,res},
cleanup=(Quiet[Close[ProcessConnection[fer,#]]&/@{"StandardInput","StandardOutput","StandardError"}];)&;
file=OpenWrite[in];
WriteString[file,ReadString[#]]&/@OptionValue[LibraryLoad];
WriteString[file,FermatSession::switches<>"
"<>str<>"
&(S='"<>out<>"');
&s;
&q;
&x;"];
Close[file];
If[!OptionValue[Run],Return[in]];
FCStaticMonitor[
CheckAbort[
Check[fer=StartProcess[$FermatCMD],Message[FermatSession::fail,$FermatCMD];cleanup[];DeleteFile[{in,out}];KillProcess[fer];Abort[]];
(*WriteLine[fer,"&(R='"<>#<>"');"]&/@OptionValue[LibraryLoad];*)
WriteLine[fer,"&(R='"<>in<>"');"];
While[ProcessStatus[fer]=="Running",
line=ReadLine[fer];
If[line=!=EndOfFile,If[StringMatchQ[line,(StartOfString~~"\\*\\*\\*"~~__)],AppendTo[log,Style[line,Red]];monitor=mfunc[monitor,line];error=True,
AppendTo[log,line];
monitor=mfunc[monitor,line];
If[StringMatchQ[line,"*>"]&&error,Print[Sequence@@(Style[#,Small]&/@Riffle[log,"\n"])];cleanup[];DeleteFile[{in,out}];KillProcess[fer];Abort[]]]];
];,
(*Clean up if user aborts evaluation*)
cleanup[];DeleteFile[{in,out}];KillProcess[fer];Abort[]
],"Running Fermat...",1];
If[OptionValue[DeleteFile],
res=ReadString[out,EndOfFile];
cleanup[];
DeleteFile[{in,out}];
res,
cleanup[];
DeleteFile[in];
out
]
]
];


FermatDetachedSession::fail="Something went wrong when invoking fermat with \"`1`\". Setting variable $FermatCMD to different value might help.";


todo["check that FermatDetachedSession works"];


FermatDetachedSession::switches="&_t;";


Options[FermatDetachedSession]:={Run->True,In->Automatic,Out->Automatic,LibraryLoad->{}};


FermatDetachedSession[str_String,OptionsPattern[]]:=Module[
{file,
in=Replace[OptionValue[In],Automatic:>uniquefile["in"]],
out=Replace[OptionValue[Out],Automatic:>uniquefile["out"]],
fer,log={},line,error=False,
cleanup,res},
cleanup=(Quiet[DeleteFile[in];DeleteFile[out]];
KillProcess[fer,15];
If[ProcessStatus[fer]!="Finished",WriteLine[fer,"&q;"]])&;
file=OpenWrite[in];
WriteString[file,FermatDetachedSession::switches<>"\n\n!!('Input: "<>in<>"');\n\n"<>str<>"
&(S='"<>out<>"');
&s;
!!('Output: "<>out<>"');
&q;
&x;"];
Close[file];
If[!OptionValue[Run],Return[in]];
Check[fer=StartProcess[$FermatCMD],Message[FermatDetachedSession::fail,$FermatCMD]];
WriteLine[fer,"&(R='"<>#<>"');"]&/@OptionValue[LibraryLoad];
WriteLine[fer,"&(R='"<>in<>"');"];
fer
];


GetOutput[fer_]:=Module[{stdout,out},
If[ProcessStatus[fer]=="Running",Return[$Failed]];stdout=ReadString[fer,EndOfBuffer];
out=First@StringCases[stdout,RegularExpression["Output: (.+)"]:>"$1"];
ReadString[out,EndOfFile]
]


GetInput[fer_]:=Module[{stdout,in},
If[ProcessStatus[fer]=="Running",Return[$Failed]];stdout=ReadString[fer,EndOfBuffer];
in=First@StringCases[stdout,RegularExpression["Input: (.+)"]:>"$1"];
ReadString[in,EndOfFile]
]


fermatspecials={"&_n":>"",a1:DigitCharacter~~" "~~a2:DigitCharacter:>a1<>a2};


uniquefile[s_String]:=Module[{i=1,fn},While[FileExistsQ[fn=$FermatTempDir<>s<>ToString[i]],i++];fn]


mat2str::usage="mat2str[smat] coverts Mathematica matrix to Fermat sparse array"
imat2str[m_]:=StringRiffle[Map["    "<>ToString[#,InputForm]&,Transpose[m],{2}],",\n\n",",\n"];
mat2str[m_,mn_String]:=Module[{l=StringRiffle[ToString/@Dimensions[m],","]},"Array "<>mn<>"["<>l<>"];\n["<>mn<>"] := [(\n"<>imat2str[m]<>"\n)];"]


smat2str::usage="smat2str[smat] coverts Mathematica sparse matrix to Fermat sparse array";
smat2str[smat_,nm_String]:=Module[{r,c},{r,c}=Dimensions[smat];"Array "<>nm<>"["<>ToString[r]<>","<>ToString[c]<>"] Sparse;\n["<>nm<>"] := "<>ismat2str[smat]<>";"];
ismat2str[smat_]:=iarules2str[Most@ArrayRules@smat];
iarules2str[{}]:="[ ]";
iarules2str[arules_]:="[ "<>StringRiffle[StringReplace[ToString[Flatten[#/.Rule->List,1],InputForm]&/@MapAt[Last,GroupBy[SortBy[arules,First],First@*First]/.Association->List,{All,2,All,1}],{"{"->"[ ","}"->"] "}],"\n"]<>"]"


var2str=StringRiffle["  &(J="<>ToString[#]<>");"&/@#,"\n"]&;


str2scl[stream_,sn_String,rule_List:{}]:=Module[{s,e,r,c,start},
s=First@StringPosition[stream,"\n "<>sn<>" := ",1];
e=Last[s]+First@StringPosition[StringDrop[stream,Last[s]],";",1];
ToExpression[StringReplace[StringTake[stream,{Last[s]+1,First[e]-1}],Join[rule,fermatspecials]]]
];


str2mat[stream_,mn_String,rule_List:{}]:=Module[{s,e,r,c,start},
s=First@StringPosition[stream,("\nArray "<>mn<>"[")~~(DigitCharacter..)~~","~~(DigitCharacter..)~~"];\n["<>mn<>"] := ["~~("("|"["),1];
e=Last[s]+First@StringPosition[StringDrop[stream,Last[s]],(")"|"]")~~"];",1];
start=StringTake[stream,s];
{r,c}=First@StringCases[start,"["~~r:(DigitCharacter..)~~","~~c:(DigitCharacter..)~~"]":>ToExpression["{"<>r<>","<>c<>"}"]];
If[StringTake[start,-1]=="(",Transpose@Partition[#,r],Partition[#,c]]&[ToExpression["{"<>StringReplace[StringTake[stream,{Last[s]+1,First[e]-1}],Join[rule,fermatspecials]]<>"}"]]
];


str2smat[stream_,mn_String,rule_List:{}]:=SparseArray[Flatten[Function[r,{r[[1]],#1}->#2&@@@r[[2;;]]]/@str2sarr[stream,mn,rule]]];


str2sarr[stream_,mn_String,rule_List:{}]:=Module[{s,e,r,c,start},
s=First@StringPosition[stream,("\nArray "<>mn<>"[")~~(DigitCharacter..)~~","~~(DigitCharacter..)~~"] Sparse;\n["<>mn<>"] := [",1];
e=Last[s]+First@StringPosition[StringDrop[stream,Last[s]],"];",1];
start=StringTake[stream,s];
{r,c}=First@StringCases[start,"["~~r:(DigitCharacter..)~~","~~c:(DigitCharacter..)~~"]":>ToExpression["{"<>r<>","<>c<>"}"]];
ToExpression[Fold[StringReplace,StringTake[stream,{Last[s],First[e]}],{{"\n"->""},{"]"~~(" "...)~~"["->"], ["},{"["->"{","]"->"}"},fermatspecials,rule}]]
]


canmult=MatchQ[#,{{_,_}..}]&&MatchQ[DeleteDuplicates/@Partition[Take[Flatten[#],{2,-2}],2],{{_}...}]&;


If[NameQ["Global`$FermaticaTODO"]&&Symbol["Global`$FermaticaTODO"],
Print["TODO list:"];
Print[Style["\[FilledSmallCircle] "<>#,{"Text",Small}]]&/@todolist];


End[];


EndPackage[]



